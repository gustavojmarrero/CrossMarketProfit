// ./config/keepaConfig.js
const axios = require("axios").default;
require("dotenv").config();

const keepaClient = axios.create({
    baseURL: 'https://api.keepa.com/',
    timeout: 10000 // puedes configurar un tiempo límite si lo deseas
});

const keepaApiKey = process.env.KEEPA_API_KEY;

// Función unificada para realizar llamadas a la API de Keepa
const callKeepaAPI = async (endpoint, params = {}) => {
    try {
        const response = await keepaClient.get(endpoint, {
            params: { ...params, key: keepaApiKey } // Agregar la API key a los parámetros
        });
        return response.data;
    } catch (error) {
        console.error(`Error al realizar la consulta a la API de Keepa en ${endpoint}:`, error);
        throw error; // Lanzar error para manejo externo si es necesario
    }
};



module.exports = {
    callKeepaAPI
};
// ./config/meliConfig.js
const axios = require("axios").default;
const setupQueue = require('./setupQueque'); // Importa la función que configura la cola
const credentials = require('../models/meliCredentials');

const getAccessTokenFromDB = async () => {
    const {access_token} = await credentials.findOne({}).exec();
    return access_token;
}

let queue;

const initQueue = async () => {
    if (!queue) {
        queue = await setupQueue(); // Inicializa la cola solo si no está ya inicializada
    }
};

const meliRequest = async (endpoint, method = 'GET', data = null, config = {}) => {
    // Actualiza el contador de llamadas

    
    await initQueue(); // Asegura que la cola esté inicializada antes de usarla
    const accessToken = await getAccessTokenFromDB();
    try {
        const response = await queue.add(() => 
            axios({
                url: `https://api.mercadolibre.com/${endpoint}`,
                method: method,
                data: data,
                headers: {
                    Authorization: `Bearer ${accessToken}`,
                    ...config.headers
                },
                ...config
            })
        );
        return { success: true, data: response.data };
    } catch (error) {
        if (error.response?.status === 429) {
            console.log(`Info: Too many requests for ${endpoint}`);
            return { success: false, error: 'Too many requests' };
        }

        if (error.response?.data?.message === 'No winners found') {
            console.log(`Info: No winners found for ${endpoint}`);
            return { success: false, error: 'No winners found' };
        } else {
          //  console.error(`Error al hacer la solicitud a MercadoLibre con el método ${method}:`, error);
            return { success: false, error: error.response?.data?.message || error.message };
        }
    }
};

module.exports = { meliRequest };// ./config/googleSheetsConfig.js
const { google } = require('googleapis');
require('dotenv').config();

const authenticate = async () => {
  const credentials = JSON.parse(process.env.GOOGLE_CREDENTIALS);
  const auth = new google.auth.GoogleAuth({
    credentials: credentials,
    scopes: ['https://www.googleapis.com/auth/spreadsheets', 'https://www.googleapis.com/auth/drive']
  });
  return auth;
};

const sheets = async () => {
  const auth = await authenticate();
  return google.sheets({ version: 'v4', auth });
};

const readSheet = async (spreadsheetId, range) => {    
  const gsheets = await sheets();
  const result = await gsheets.spreadsheets.values.get({
    spreadsheetId,
    range,
    valueRenderOption: 'UNFORMATTED_VALUE'
  });
  return result.data.values;
};

const updateSheet = async (spreadsheetId, range, values) => {
  const gsheets = await sheets();
  const result = await gsheets.spreadsheets.values.append({
    spreadsheetId,
    range,
    valueInputOption: 'USER_ENTERED',
    resource: { values },
  });
  return result.data;
};

const clearSheet = async (spreadsheetId, range) => {
  try {
    const gsheets = await sheets();
    const result = await gsheets.spreadsheets.values.clear({
      spreadsheetId,
      range
    });
    return result.data;
  } catch (error) {
    console.error('Error al borrar los valores:', error);
    throw error;
  }
};


module.exports = {
  readSheet,
  updateSheet,
  clearSheet,
};// ./config/mongoDbConfig.js
require('dotenv').config();

const mongoose = require('mongoose');

// Obtenemos la URI de MongoDB
const mongoURI = `${process.env.URI_BD_GUATEVER}?maxPoolSize=5`; 



// Conectamos a MongoDB
mongoose.connect(mongoURI);
mongoose.set('strictQuery', false);

// Escuchamos evento de conexión
mongoose.connection.once('open', () => {
  console.log('Conectado a MongoDB');
});

// Escuchamos errores
mongoose.connection.on('error', err => {
  console.error(err);
});

// Exportamos la conexión
module.exports = mongoose.connection;
// ./config/setupQueque.js
async function setupQueue() {
    const PQueue = (await import('p-queue')).default;
    const queue = new PQueue({ concurrency: 4, interval: 500, intervalCap: 2 });
    return queue;
}

module.exports = setupQueue;// ./config/amazonConfig.js
const SellingPartner = require('amazon-sp-api');
require("dotenv").config();

const spClient = new SellingPartner({
    region: 'na', 
    refresh_token: process.env.AMAZON_REFRESH_TOKEN 
});


module.exports = spClient;// ./utils/index.js
const fs = require('fs');
const path = require('path');
const moment = require('moment');

const MAX_RETRIES = 3;
const RETRY_DELAY = 5000;

const isValidUPC = (upc) =>{
    if (typeof upc !== 'string') {
        console.log('El UPC debe ser una cadena de texto.');
        return false;
    }
    // Para UPC-A (12 dígitos) o EAN-13 (13 dígitos)
    if (upc.length !== 12 && upc.length !== 13) {
        console.log('El UPC debe tener 12 o 13 dígitos.');
        return false;
    }
    return true;
}

const chunkArray = (arr, chunkSize) => {
    let result = [];
    for (let i = 0; i < arr.length; i += chunkSize) {
        result.push(arr.slice(i, i + chunkSize));
    }
    return result;
};

const formatNumber =(n)=> {
    // format number 1000000 to 1,234,567
    return n.replace(/\D/g, "").replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  }

  const formatCurrency = (input, currency, blur)=>{
    // appends $ to value, validates decimal side
    // and puts cursor back in right position.
    // get input value
    var input_val = input.value;
    // don't validate empty input
    if (input_val === "") {
      return;
    }

    // original length
    var original_len = input_val.length;

    // initial caret position
    var caret_pos = input.selectionStart;

    // check for decimal
    if (input_val.indexOf(".") >= 0) {
      // get position of first decimal
      // this prevents multiple decimals from
      // being entered
      var decimal_pos = input_val.indexOf(".");

      // split number by decimal point
      var left_side = input_val.substring(0, decimal_pos);
      var right_side = input_val.substring(decimal_pos);

      // add commas to left side of number
      left_side = formatNumber(left_side);

      // validate right side
      right_side = formatNumber(right_side);

      // On blur make sure 2 numbers after decimal
      if (blur === "blur") {
        right_side += "00";
      }

      // Limit decimal to only 2 digits
      right_side = right_side.substring(0, 2);

      // join number by .
      input_val = currency + left_side + "." + right_side;
    } else {
      // no decimal entered
      // add commas to number
      // remove all non-digits
      input_val = formatNumber(input_val);
      input_val = currency + input_val;

      // final formatting
      if (blur === "blur") {
        input_val += ".00";
      }
    }

    // send updated string to input
    input.value = input_val;

    // put caret back in the right position
    var updated_len = input_val.length;
    caret_pos = updated_len - original_len + caret_pos;
    input.setSelectionRange(caret_pos, caret_pos);
  }
  const retryOnFail = async (
    func,
    maxRetries = 5,
    initialDelay = 20000
  ) => {
    let delay = initialDelay;
  
    for (let i = 0; i < maxRetries; i++) {
      console.log(`Retrying ${i + 1} of ${maxRetries}...`);
      const result = await func();
  
      if (result.success) {
        return result;
      } else if (result.error === 'Too many requests' || result.error === 'too_many_requests') {
        console.log('Received 429 Too Many Requests, waiting before retrying...');
        await new Promise((res) => setTimeout(res, delay));
        delay *= 2; // Incrementa el retraso exponencialmente
      } else {
        console.error(`Error in retryOnFail: ${result.error}`);
        if (i === maxRetries - 1) throw new Error(result.error);
        await new Promise((res) => setTimeout(res, delay));
      }
    }
  };
  const roundToTwoDecimal = (num) => {
    return Math.round((num + Number.EPSILON) * 100) / 100;
  };

// Ruta del archivo JSON
const counterFilePath = path.join(__dirname, '../data/callCounter.json');

// Leer el archivo JSON con manejo de archivo vacío
const readCallCounter = () => {
  try {
    const data = fs.readFileSync(counterFilePath, 'utf-8');
    
    // Si el archivo está vacío, retorna un array vacío
    if (!data || data.trim() === '') {
      console.log("Archivo JSON vacío, inicializando...");
      return [];
    }

    return JSON.parse(data); // Intenta parsear el contenido del archivo
  } catch (error) {
    console.error('Error al leer el contador de llamadas o archivo malformado:', error);
    return []; // Retorna un array vacío si el archivo no existe o está malformado
  }
};

// Escribir el archivo JSON
const writeCallCounter = (counterData) => {
  try {
    fs.writeFileSync(counterFilePath, JSON.stringify(counterData, null, 2));
  } catch (error) {
    console.error('Error al escribir el contador de llamadas:', error);
  }
};

// Actualizar el contador
const updateCallCounter = () => {
  const currentDate = moment().format('YYYY-MM-DD');
  let counterData = readCallCounter();
  
  // Verifica si ya hay un registro para el día actual
  const todayEntry = counterData.find(entry => entry.day === currentDate);
  
  if (todayEntry) {
    // Incrementa el contador si ya existe una entrada para hoy
    todayEntry.count += 1;
  } else {
    // Crea una nueva entrada para hoy si no existe
    counterData.push({
      day: currentDate,
      count: 1
    });
  }

  // Escribe los datos actualizados en el archivo JSON
  writeCallCounter(counterData);
};
const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));
module.exports = {
    isValidUPC,
    chunkArray,
    formatCurrency,
    retryOnFail,
    roundToTwoDecimal,
    updateCallCounter,
    delay
};// ./models/asinCatalogMapping.js
const db = require("../config/mongoDbConfig");
const { Schema } = require("mongoose");

const asinCatalogSchema = new Schema(
  {
    asin: { type: String, unique: true },
    amazonPrice: { type: Number, default: 0 },
    amazonPriceUpdatedAt: { type: Date, default: null },
    gtin: { type: String, default: null },
    mlCatalogId: { type: String, default: null },
    mlCategoryId: { type: String, default: null },
    itemIds: [{ type: String, default: [] }],
    identifiers: [{ type: String, default: null }],  // Array de identificadores (GTIN, EAN, UPC)
    image: { type: String, default: null },
    catalogIdentifier: { type: String, default: null },  // Identificador que coincide con el catálogo en MercadoLibre
    averagePriceLast30Days: { type: Number, default: 0 },
    averagePriceLast90Days: { type: Number, default: 0 },
    averagePriceLast180Days: { type: Number, default: 0 },
    priceHistory: [
      {
        price: Number,
        date: { type: Date, default: Date.now },
      },
    ],
    title: { type: String, default: null },
    firstListingPrice: { type: Number, default: 0 },
    firstListingPriceUpdatedAt: { type: Date, default: null },  
    totalVisitsLast30Days: { type: Number, default: 0 },
    totalVisitsLast30DaysUpdatedAt: { type: Date, default: null },  
    mlCatalogIdUpdatedAt: { type: Date, default: null },  
    mlSaleCommission: { type: Number, default: 0 },
    mlShippingCost: { type: Number, default: 0 },
    mlShippingCostsUpdatedAt: { type: Date, default: null },  
    estimatedProfit: { type: Number, default: 0 },
    isMatchCorrect: { type: Boolean, default: true },
  },
  {
    timestamps: true,
  }
);

const AsinCatalogMapping = db.model("AsinCatalogMapping", asinCatalogSchema);

module.exports = AsinCatalogMapping;// ./models/meliCredentials.js
const db = require('../config/mongoDbConfig');
const { Schema } = require('mongoose');

const melicrentialsSchema = new Schema({
    access_token: String,
    token_type: String,
    expires_in: Number,
    user_id:Number,
    refresh_token: String,
    last_update: Date,
},
 {
    collection: 'melicrentials'
}

);
module.exports = db.model('melicrentials', melicrentialsSchema );// ./controllers/catalogController.js
const Bluebird = require("bluebird");
const moment = require("moment");
const {
  readSheet,
  updateSheet,
  clearSheet,
} = require("../config/googleSheetsConfig");
const { meliRequest } = require("../config/meliConfig");
const {
  getAsinPrice,
  getAsinDetails,
} = require("../services/amazonService");
const {
  findProductsFromKeepa,
  getTokenLeft,
} = require("../services/keepaService");
const AsinCatalogMapping = require("../models/asinCatalogMapping");
const { delay } = require("../utils");

class AsinCatalogProcessor {
  constructor() {
    this.categoryFeeCache = {};
  }

  async addNewAsins() {
    try {
      const tokenLeft = getTokenLeft();
      if (tokenLeft < 1500) {
        console.log("No hay suficientes tokens para agregar nuevos ASINs");
        return;
      }

      const categories = [
        "13848848011", // Automotriz y Motocicletas
        "9482650011", // Bebé
        "11260452011", // Belleza
        "9482660011", // Deportes y Aire Libre
        "9482670011", // Herramientas y Mejoras del Hogar
        "9482593011", // Hogar y Cocina
        "11076223011", // Industria Empresas y Ciencia
        "13848858011", // Instrumentos Musicales
        "16215357011", // Jardín
        "11260442011", // Juguetes y Juegos
        "9673844011", // Oficina y Papelería
        "11782336011", // Productos para animales
        "13848838011", // Ropa, Zapatos y Accesorios
        "9482610011", // Salud y Cuidado Personal
      ];

      // Obtener todos los ASINs de las categorías en paralelo
      const asinsArrays = await Promise.all(
        categories.map((category) => findProductsFromKeepa(category))
      );
      const allAsins = asinsArrays.flat();

      console.log(`Se encontraron ${allAsins.length} ASINs en Keepa.`);

      // Obtener los ASINs existentes y usar un Set para eficiencia
      const existingAsinsArray = await AsinCatalogMapping.find().distinct("asin");
      const existingAsins = new Set(existingAsinsArray);

      // Filtrar los nuevos ASINs que no están en la base de datos
      const newAsins = allAsins.filter((asin) => !existingAsins.has(asin));
      console.log(`Se encontraron ${newAsins.length} ASINs nuevos.`);

      if (newAsins.length > 0) {
        // Convertir cada ASIN en un objeto según el esquema de AsinCatalogMapping
        const newAsinsObjects = newAsins.map((asin) => ({ asin }));

        await AsinCatalogMapping.insertMany(newAsinsObjects);
        console.log(
          `Se agregaron ${newAsins.length} nuevos ASINs a la base de datos.`
        );
      } else {
        console.log("No hay nuevos ASINs para agregar.");
      }
    } catch (error) {
      console.error("Error en addNewAsins:", error);
    }
  }

  async addAsinDetails() {
    try {
      await this.processMappingsInBatch(
        { title: null },
        this.processAsinDetails.bind(this)
      );
      console.log("Actualización de detalles de ASIN completada.");
    } catch (error) {
      console.error("Error en addAsinDetails:", error);
    }
  }

  async processAsinDetails(mapping) {
    try {
      const { uniqueIdentifiers, title, image } = await getAsinDetails(
        mapping.asin
      );

      if (uniqueIdentifiers.length > 0 || title !== "Sin título" || image) {
        console.log(`ASIN: ${mapping.asin}`);
        if (uniqueIdentifiers.length > 0) {
          console.log(`Identificadores: ${uniqueIdentifiers.join(", ")}`);
        }
        if (title !== "Sin título") {
          console.log(`Título: ${title}`);
        }
        if (image) {
          console.log(`Imagen: ${image}`);
        }
        return {
          updateOne: {
            filter: { _id: mapping._id },
            update: {
              $set: {
                identifiers: uniqueIdentifiers,
                title,
                image,
              },
            },
          },
        };
      } else {
        console.log(
          `No se encontraron detalles para el ASIN ${mapping.asin}.`
        );
        return null;
      }
    } catch (error) {
      console.error(`Error procesando ASIN ${mapping.asin}:`, error);
      return null;
    }
  }

  async addCatalogIds() {
    const thirtyDaysAgo = moment().subtract(30, "days").toDate();
    const queryFilter = {
      identifiers: { $exists: true, $not: { $size: 0 } },
      mlCatalogId: null,
      $or: [
        { mlCatalogIdUpdatedAt: { $exists: false } },
        { mlCatalogIdUpdatedAt: { $lte: thirtyDaysAgo } },
        { mlCatalogIdUpdatedAt: null },
      ],
    };

    await this.processMappingsInBatch(
      queryFilter,
      this.processCatalogIdUpdate.bind(this),
      200
    );
    console.log("Agregación de mlCatalogId completada.");
  }

  async processCatalogIdUpdate(mapping) {
    for (const identifier of mapping.identifiers) {
      try {
        const searchResponse = await meliRequest(
          `products/search?status=active&site_id=MLM&product_identifier=${identifier}`
        );

        if (searchResponse.success && searchResponse.data.results.length > 0) {
          const catalogId = searchResponse.data.results[0].id;
          console.log(
            `Se encontró mlCatalogId ${catalogId} para el identificador ${identifier}`
          );

          return this.createUpdateOperation(mapping._id, {
            mlCatalogId: catalogId,
            catalogIdentifier: identifier,
            mlCatalogIdUpdatedAt: new Date(),
          });
        } else {
          console.log(
            `No se encontró mlCatalogId para el identificador ${identifier}`
          );
        }
      } catch (error) {
        console.error(`Error buscando el identificador ${identifier}:`, error);
      }
    }

    console.log(
      `No se encontró mlCatalogId para los identificadores del ASIN: ${mapping.asin}`
    );
    return this.createUpdateOperation(mapping._id, {
      mlCatalogId: null,
      mlCatalogIdUpdatedAt: new Date(),
    });
  }

  createUpdateOperation(id, updateFields) {
    return {
      updateOne: {
        filter: { _id: id },
        update: { $set: updateFields },
      },
    };
  }

  async updateCatalogPrices() {
    const twentyFourHoursAgo = moment().subtract(24, "hours").toDate();
    const fiveDaysAgo = moment().subtract(5, "days").toDate();
    const twentyDaysAgo = moment().subtract(20, "days").toDate();

    const queryFilter = {
      mlCatalogId: { $nin: [null, "no_catalog"] },
      isMatchCorrect: { $ne: false },
      $or: [
        { firstListingPriceUpdatedAt: { $exists: false } },
        { firstListingPriceUpdatedAt: null },
        {
          $and: [
            { firstListingPrice: 0 },
            {
              priceHistory: {
                $elemMatch: {
                  price: 0,
                  date: { $gte: twentyDaysAgo },
                },
              },
            },
            { firstListingPriceUpdatedAt: { $lte: fiveDaysAgo } },
          ],
        },
        {
          $and: [
            { firstListingPrice: 0 },
            {
              priceHistory: {
                $elemMatch: {
                  price: { $gt: 0 },
                  date: { $gte: twentyDaysAgo },
                },
              },
            },
            { firstListingPriceUpdatedAt: { $lte: twentyFourHoursAgo } },
          ],
        },
        {
          $and: [
            { firstListingPrice: 0 },
            { itemIds: { $size: 0 } },
            { firstListingPriceUpdatedAt: { $lte: fiveDaysAgo } },
          ],
        },
        {
          $and: [
            { firstListingPrice: { $gt: 0 } },
            { firstListingPriceUpdatedAt: { $lte: twentyFourHoursAgo } },
          ],
        },
      ],
    };

    await this.processMappingsInBatch(
      queryFilter,
      this.processCatalogPriceUpdate.bind(this)
    );
    console.log("Actualización de precios de catálogo completada.");
  }

  async processCatalogPriceUpdate(mapping) {
    const itemsResponse = await meliRequest(
      `/products/${mapping.mlCatalogId}/items`
    );
    const now = new Date();
    if (itemsResponse.success && itemsResponse.data.results.length > 0) {
      const firstListingPrice = itemsResponse.data.results[0].price;
      const itemIds = new Set([
        ...(mapping.itemIds || []),
        ...itemsResponse.data.results.map((item) => item.item_id),
      ]);
      const priceHistory = [
        ...(mapping.priceHistory || []),
        { price: firstListingPrice, date: now },
      ];
      const averagePriceLast30Days = this.calculateAveragePrice(
        priceHistory,
        30,
        now
      );
      const averagePriceLast90Days = this.calculateAveragePrice(
        priceHistory,
        90,
        now
      );
      const averagePriceLast180Days = this.calculateAveragePrice(
        priceHistory,
        180,
        now
      );

      console.log(
        `Precio y IDs de listado actualizados para mlCatalogId ${mapping.mlCatalogId}.`
      );
      return {
        updateOne: {
          filter: { _id: mapping._id },
          update: {
            $set: {
              firstListingPrice,
              itemIds: Array.from(itemIds),
              averagePriceLast30Days,
              averagePriceLast90Days,
              averagePriceLast180Days,
              firstListingPriceUpdatedAt: now,
            },
            $push: { priceHistory: { price: firstListingPrice, date: now } },
          },
        },
      };
    } else {
      console.log(
        `No se encontraron listados activos para el mlCatalogId ${mapping.mlCatalogId}.`
      );
      return {
        updateOne: {
          filter: { _id: mapping._id },
          update: {
            $set: {
              firstListingPrice: 0,
              firstListingPriceUpdatedAt: now,
            },
            $push: { priceHistory: { price: 0, date: now } },
          },
        },
      };
    }
  }

  calculateAveragePrice(priceHistory, days, now) {
    const pastDate = new Date(now.getTime() - days * 24 * 60 * 60 * 1000);
    const relevantPrices = priceHistory.filter(
      (entry) => entry.date >= pastDate
    );
    const averagePrice =
      relevantPrices.reduce((acc, entry) => acc + entry.price, 0) /
      relevantPrices.length;
    return averagePrice || 0;
  }

  async addCategoryId() {
    await this.processMappingsInBatch(
      {
        itemIds: { $exists: true, $not: { $size: 0 } },
        mlCategoryId: null,
      },
      this.processCategoryIdUpdate.bind(this)
    );
    console.log("Actualización de categorías completada.");
  }

  async processCategoryIdUpdate(mapping) {
    const itemId = mapping.itemIds[0];
    const itemResponse = await meliRequest(
      `items/${itemId}?attributes=category_id`
    );
    if (itemResponse.success && itemResponse.data.category_id) {
      console.log(
        `Categoría encontrada para el item ${itemId}: ${itemResponse.data.category_id}`
      );
      return {
        updateOne: {
          filter: { _id: mapping._id },
          update: { $set: { mlCategoryId: itemResponse.data.category_id } },
        },
      };
    } else {
      console.log(
        `No se encontró categoría para el item ${itemId} en el CatalogID ${mapping.mlCatalogId}.`
      );
      return null;
    }
  }

  async addFee() {
    await this.processMappingsInBatch(
      {
        mlCategoryId: { $exists: true, $ne: null },
        $or: [{ mlSaleCommission: null }, { mlSaleCommission: 0 }],
      },
      this.processFeeUpdate.bind(this)
    );
    console.log("Actualización de comisiones completada.");
  }

  async processFeeUpdate(mapping) {
    const categoryId = mapping.mlCategoryId;

    // Verifica si ya tenemos la comisión almacenada en la caché
    if (this.categoryFeeCache[categoryId] !== undefined) {
      console.log(
        `Usando la comisión en caché para CatalogID ${mapping.mlCatalogId} con comisión ${this.categoryFeeCache[categoryId]}`
      );
      return {
        updateOne: {
          filter: { _id: mapping._id },
          update: {
            $set: { mlSaleCommission: this.categoryFeeCache[categoryId] },
          },
        },
      };
    }

    // Si no está en la caché, consulta la API de Mercado Libre
    const feeResponse = await meliRequest(
      `/sites/MLM/listing_prices?price=499&listing_type_id=gold_special&category_id=${categoryId}&attributes=sale_fee_details`
    );

    if (feeResponse.success && feeResponse.data.sale_fee_details) {
      const percentageFee =
        feeResponse.data.sale_fee_details.percentage_fee / 100;

      // Almacena la comisión en la caché
      this.categoryFeeCache[categoryId] = percentageFee;

      console.log(
        `Actualización programada para CatalogID ${mapping.mlCatalogId} con comisión ${percentageFee}`
      );
      return {
        updateOne: {
          filter: { _id: mapping._id },
          update: { $set: { mlSaleCommission: percentageFee } },
        },
      };
    } else {
      console.log(
        `No se pudo obtener la comisión para el mlCatalogId ${mapping.mlCatalogId}.`
      );
      return null;
    }
  }

  async updateShippingCostsDaily() {
    await this.processMappingsInBatch(
      {
        mlCatalogId: { $nin: [null, "no_catalog"] },
        isMatchCorrect: { $ne: false },
        $or: [{ mlShippingCost: null }, { mlShippingCost: 0 }],
      },
      this.processShippingCostUpdate.bind(this)
    );
    console.log("Actualización diaria de costos de envío completada.");
  }

  async updateShippingCostsMonthly() {
    const monthAgo = moment().subtract(1, "months").toDate();
    await this.processMappingsInBatch(
      {
        mlCatalogId: { $nin: [null, "no_catalog"] },
        itemIds: { $ne: null, $not: { $size: 0 } },
        isMatchCorrect: { $ne: false },
        $or: [
          { mlShippingCostsUpdatedAt: { $exists: false } },
          { mlShippingCostsUpdatedAt: { $lte: monthAgo } },
          { mlShippingCostsUpdatedAt: null },
        ],
      },
      this.processShippingCostUpdate.bind(this)
    );
    console.log("Actualización mensual de costos de envío completada.");
  }

  async processShippingCostUpdate(mapping) {
    let shippingCost = 91; // Costo predeterminado

    if (mapping.itemIds && mapping.itemIds.length > 0) {
      for (const itemId of mapping.itemIds) {
        try {
          const shippingOptionsResponse = await meliRequest(
            `/items/${itemId}/shipping_options?zip_code=77533`
          );

          if (
            shippingOptionsResponse.success &&
            shippingOptionsResponse.data.options &&
            shippingOptionsResponse.data.options.length > 0
          ) {
            const standardShippingOption =
              shippingOptionsResponse.data.options.find(
                (option) =>
                  option.name.includes("Estándar") && option.base_cost > 0
              );
            shippingCost = standardShippingOption
              ? standardShippingOption.list_cost
              : 91;
            break;
          } else {
            console.error(
              `Error obteniendo opciones de envío para el item ${itemId}: ${shippingOptionsResponse.error}`
            );
          }
        } catch (error) {
          if (error.status === 400 && error.error === "bad_request") {
            console.warn(`El ItemId ${itemId} no tiene opciones de envío.`);
          } else {
            console.error(
              `Error en la llamada a la API para el item ${itemId}: ${error.message}`
            );
          }
        }
      }
    }

    console.log(
      `Actualización programada para CatalogID ${mapping.mlCatalogId} con costo de envío ${shippingCost}`
    );
    return {
      updateOne: {
        filter: { _id: mapping._id },
        update: {
          $set: {
            mlShippingCost: shippingCost,
            mlShippingCostsUpdatedAt: new Date(),
          },
        },
      },
    };
  }

  async updateTotalVisitsLast30Days() {
    const eightDaysAgo = moment().subtract(8, "days").toDate();

    await this.processMappingsInBatch(
      {
        itemIds: { $ne: null, $not: { $size: 0 } },
        isMatchCorrect: { $ne: false },
        $or: [
          { totalVisitsLast30DaysUpdatedAt: { $lte: eightDaysAgo } },
          { totalVisitsLast30DaysUpdatedAt: { $exists: false } },
          { totalVisitsLast30DaysUpdatedAt: null },
        ],
      },
      this.processTotalVisitsUpdate.bind(this)
    );

    console.log(
      "Actualización de visitas totales de los últimos 30 días completada."
    );
  }

  async processTotalVisitsUpdate(mapping) {
    let totalVisits = 0;
    console.log(
      `Actualizando visitas totales de los últimos 30 días para catalogo Id ${mapping.mlCatalogId}...`
    );
    for (const itemId of mapping.itemIds) {
      await delay(500);
      const visitsResponse = await meliRequest(
        `/items/${itemId}/visits/time_window?last=30&unit=day`
      );
      if (visitsResponse.success) {
        totalVisits += visitsResponse.data.total_visits;
      } else {
        console.error(
          `Error obteniendo visitas para el item ${itemId}: ${visitsResponse.error}`
        );
      }
    }

    console.log(
      `Visitas actualizadas para mlCatalogId ${mapping.mlCatalogId}: ${totalVisits}`
    );
    return {
      updateOne: {
        filter: { _id: mapping._id },
        update: {
          $set: {
            totalVisitsLast30Days: totalVisits,
            totalVisitsLast30DaysUpdatedAt: new Date(),
          },
        },
      },
    };
  }

  async updateAmazonPrice() {
    const twentyFourHoursAgo = moment().subtract(24, "hours").toDate();
    await this.processMappingsInBatch(
      {
        mlCatalogId: { $nin: [null, "no_catalog"] },
        asin: { $ne: null },
        totalVisitsLast30Days: { $gte: 600 },
        isMatchCorrect: { $ne: false },
        $or: [
          { amazonPriceUpdatedAt: { $lte: twentyFourHoursAgo } },
          { amazonPriceUpdatedAt: null },
          { amazonPriceUpdatedAt: { $exists: false } },
        ],
      },
      this.processAmazonPriceUpdate.bind(this)
    );
    console.log("Actualización de precios de Amazon completada.");
  }

  async processAmazonPriceUpdate(mapping) {
    const asin = mapping.asin;
    const priceResponse = await getAsinPrice(asin);

    let updateFields = {};
    const now = new Date();
    if (
      priceResponse &&
      (priceResponse.Offers || priceResponse.Summary?.BuyBoxPrices)
    ) {
      const filteredBuyBoxPrices =
        priceResponse.Summary?.BuyBoxPrices?.filter((price) =>
          ["A2RIC6EIHFYJ8E", "AVDBXBAVVSXLQ"].includes(price?.sellerId)
        );

      const buyBoxPriceObj = filteredBuyBoxPrices?.reduce(
        (minOffer, price) => {
          let offerPrice = price?.ListingPrice?.Amount || 0;

          if (
            offerPrice > 0 &&
            (!minOffer || offerPrice < minOffer.ListingPrice.Amount)
          ) {
            return price;
          }

          return minOffer;
        },
        null
      );

      const buyBoxPrice = buyBoxPriceObj?.ListingPrice?.Amount;

      const allOffers = [...(priceResponse.Offers || [])];

      if (buyBoxPrice) {
        allOffers.push({
          ListingPrice: { Amount: buyBoxPrice },
          SellerId: buyBoxPriceObj.sellerId,
        });
      }

      const filteredOffers = allOffers.filter((offer) =>
        ["A2RIC6EIHFYJ8E", "AVDBXBAVVSXLQ"].includes(offer.SellerId)
      );

      let amazonOffer = filteredOffers.reduce((minOffer, offer) => {
        let offerPrice = 0;
        if (offer.ListingPrice && offer.ListingPrice.Amount > 0) {
          offerPrice = offer.ListingPrice.Amount;
        } else if (
          offer.quantityDiscountPrices &&
          offer.quantityDiscountPrices.length > 0
        ) {
          offerPrice = offer.quantityDiscountPrices[0].price.Amount;
        }

        if (offerPrice > 0 && (!minOffer || offerPrice < minOffer.price)) {
          return { offer, price: offerPrice };
        }

        return minOffer;
      }, null);

      if (amazonOffer) {
        const amazonPrice = amazonOffer.price;
        console.log(`Precio de Amazon para ASIN ${asin} es ${amazonPrice}`);
        updateFields.amazonPrice = amazonPrice;
        updateFields.amazonPriceUpdatedAt = now;

        if (amazonPrice <= 0) {
          updateFields.estimatedProfit = 0;
        }
      } else {
        console.log(
          `No se encontró oferta de Amazon válida para el ASIN ${asin}. Se guardará el precio como 0.`
        );
        updateFields = {
          amazonPrice: 0,
          estimatedProfit: 0,
          amazonPriceUpdatedAt: now,
        };
      }
    } else {
      console.log(
        `No se obtuvieron ofertas para el ASIN ${asin}. Se guardará el precio como 0.`
      );
      updateFields = {
        amazonPrice: 0,
        estimatedProfit: 0,
        amazonPriceUpdatedAt: now,
      };
    }

    return {
      updateOne: {
        filter: { _id: mapping._id },
        update: { $set: updateFields },
      },
    };
  }

  async calculateProfit() {
    await this.processMappingsInBatch(
      {
        mlCatalogId: { $nin: [null, "no_catalog"] },
        isMatchCorrect: { $ne: false },
        amazonPrice: { $gt: 0 },
      },
      this.processProfitCalculation.bind(this)
    );

    console.log("Actualización de ganancias estimadas completada.");
  }

  async processProfitCalculation(mapping) {
    let estimatedProfit;

    if (mapping.amazonPrice === 0) {
      estimatedProfit = 0;
    } else if (mapping.firstListingPrice === 0) {
      estimatedProfit = 200;
    } else {
      estimatedProfit =
        mapping.firstListingPrice -
        mapping.amazonPrice -
        (mapping.mlShippingCost || 91) -
        mapping.firstListingPrice * (mapping.mlSaleCommission || 0.15);
    }

    console.log(
      `Estimación de ganancia para ASIN ${mapping.asin}: ${estimatedProfit}`
    );
    return {
      updateOne: {
        filter: { _id: mapping._id },
        update: { $set: { estimatedProfit } },
      },
    };
  }

  async uploadDataToSheet() {
    const spreadsheetId = "1F8v5JpQ-pXJ7-XyHcbHpI0whCtMo3sJSLbc95ebRoKA";
    const range = "Keepa";

    const mappings = await AsinCatalogMapping.find({
      mlCatalogId: { $nin: [null, "no_catalog"] },
      isMatchCorrect: { $ne: false },
      amazonPrice: { $gt: 0 },
      estimatedProfit: { $gt: 70 },
      totalVisitsLast30Days: { $gte: 600 },
    }).sort({ totalVisitsLast30Days: -1 });

    const values = mappings.map((mapping) => [
      `=HYPERLINK("https://www.amazon.com.mx/dp/${mapping.asin}?th=1&psc=1", "${mapping.asin}")`,
      mapping.mlCatalogId
        ? `=HYPERLINK("https://www.mercadolibre.com.mx/p/${mapping.mlCatalogId}/s", "${mapping.mlCatalogId}")`
        : "",
      mapping.image ? `=IMAGE("${mapping.image}")` : "",
      mapping.title,
      mapping.amazonPrice,
      mapping.firstListingPrice,
      mapping.averagePriceLast30Days,
      mapping.averagePriceLast90Days,
      mapping.averagePriceLast180Days,
      mapping.totalVisitsLast30Days,
      mapping.mlSaleCommission,
      mapping.mlShippingCost,
      mapping.estimatedProfit,
      mapping.priceHistory.length,
    ]);

    await clearSheet(spreadsheetId, `${range}!A2:N`);
    await updateSheet(spreadsheetId, `${range}!A2:N`, values);

    console.log("Datos subidos correctamente a Google Sheets.");
  }

  async updateNoCatalogToNull() {
    try {
      const result = await AsinCatalogMapping.updateMany(
        { mlCatalogId: "no_catalog" },
        { $set: { mlCatalogId: null } }
      );
      console.log(`${result.nModified} documentos actualizados.`);
    } catch (error) {
      console.error("Error actualizando documentos:", error);
    }
  }

  async addIsMatchCorrectField() {
    try {
      const result = await AsinCatalogMapping.updateMany(
        { isMatchCorrect: { $exists: false } },
        { $set: { isMatchCorrect: true } }
      );
      console.log(`Documentos actualizados: ${result.modifiedCount}`);
    } catch (error) {
      console.error("Error al actualizar documentos:", error);
    }
  }

  async updateIsMatchCorrectFromSheet() {
    const spreadsheetId = "1F8v5JpQ-pXJ7-XyHcbHpI0whCtMo3sJSLbc95ebRoKA";
    const sheetName = "MatcheoIncorrecto";
    const range = "A2:A";

    try {
      const asins = await readSheet(spreadsheetId, `${sheetName}!${range}`);

      if (!asins || asins.length === 0) {
        console.log("No se encontraron ASINs para actualizar.");
        return;
      }

      const asinList = asins.flat().filter((asin) => asin);

      console.log(`Se encontraron ${asinList.length} ASINs para actualizar.`);

      const updateResult = await AsinCatalogMapping.updateMany(
        { asin: { $in: asinList } },
        { $set: { isMatchCorrect: false } }
      );

      console.log(`Documentos actualizados: ${updateResult.modifiedCount}`);

      await clearSheet(spreadsheetId, `${sheetName}!${range}`);
      console.log("Valores borrados de la hoja de cálculo.");
    } catch (error) {
      console.error("Error en updateIsMatchCorrectFromSheet:", error);
    }
  }

  // Método general para procesar mappings en lotes
  async processMappingsInBatch(queryFilter, processFunction, batchSize = 200) {
    console.log(JSON.stringify(queryFilter));
    let lastId = null;
    let proceed = true;

    while (proceed) {
      const query = AsinCatalogMapping.find(queryFilter)
        .sort({ _id: 1 })
        .limit(batchSize)
        .lean();

      if (lastId) {
        query.where("_id").gt(lastId);
      }

      const mappings = await query.exec();

      if (mappings.length === 0) {
        proceed = false;
        break;
      }

      const bulkOps = (
        await Bluebird.map(mappings, processFunction, { concurrency: 5 })
      ).filter((op) => op != null);

      if (bulkOps.length > 0) {
        console.log(
          `Ejecutando operaciones en lote para ${bulkOps.length} mappings.`
        );
        await AsinCatalogMapping.bulkWrite(bulkOps);
      }

      lastId = mappings[mappings.length - 1]._id;
      proceed = mappings.length === batchSize;
    }
  }
}

module.exports = new AsinCatalogProcessor();

// ./controllers/arbitrageController.js
const asinCatalogProcessor = require("./catalogController");

const arbitrageAmazonMeli = async () => {
  try {
    console.log('Iniciando proceso de arbitraje Amazon-MercadoLibre...');

    console.log('Agregando nuevos ASINs...');
    await asinCatalogProcessor.addNewAsins();

    console.log('Agregando detalles de cada ASIN nuevo...');
    await asinCatalogProcessor.addAsinDetails();

    console.log('Agregando los CatalogId de los nuevos productos...');
    await asinCatalogProcessor.addCatalogIds();

    console.log('Actualizando los precios de referencia de los productos en el catálogo de MercadoLibre...');
    await asinCatalogProcessor.updateCatalogPrices();

    console.log('Agregando los CategoryId de los productos...');
    await asinCatalogProcessor.addCategoryId();

    console.log('Actualizando las comisiones de MercadoLibre para los nuevos productos...');
    await asinCatalogProcessor.addFee();

    console.log('Actualizando los costos de envíos de MercadoLibre para los nuevos productos...');
    await asinCatalogProcessor.updateShippingCostsDaily();

    console.log('Actualizando el total de visitas de los productos en los últimos 30 días...');
    await asinCatalogProcessor.updateTotalVisitsLast30Days();

    console.log('Actualizando los precios de Amazon para todos los productos con CatalogId...');
    await asinCatalogProcessor.updateAmazonPrice();

    console.log('Calculando la ganancia potencial de los productos...');
    await asinCatalogProcessor.calculateProfit();

    console.log('Subiendo los datos al Google Sheet...');
    await asinCatalogProcessor.uploadDataToSheet();

    console.log('Proceso de arbitraje finalizado.');
    process.exit(0); // Terminar el proceso de arbitraje cuando se hayan realizado todas las operaciones

  } catch (error) {
    console.error('Error en el proceso de arbitraje:', error);
    process.exit(1); // Terminar el proceso de arbitraje si hay un error
  }
};

arbitrageAmazonMeli();// ./services/amazonService.js

const spClient = require("../config/amazonConfig");

const getAsinPrice = async (asin) => {
// Pendiente incluir promociones
// Planea y Ahorra
// Súper 5% extra
// Súper ahorra 5%

  try {
    const params = {
      endpoint: "productPricing",
      operation: "getItemOffers",
      query: {
        MarketplaceId: "A1AM78C64UM0Y8",
        ItemCondition: "New",
        CustomerType: "Business",
      },
      path: {
        Asin: asin,
      },
    };

    const results = await spClient.callAPI(params);
   // console.log(JSON.stringify(results, null, 2));
    return results;
  } catch (error) {
    console.log(error);
  }
};

const getAsinDetails = async (asin) => {
  try {
    const params = {
      method: "GET",
      api_path: "/catalog/2022-04-01/items",
      query: {
        marketplaceIds: "A1AM78C64UM0Y8",
        includedData: ["identifiers", "attributes", "images"],
        identifiersType: ["ASIN"],
        identifiers: [asin],
      },
    };

    const results = await spClient.callAPI(params);
    // console.log(JSON.stringify(results, null, 2));
    if (results.numberOfResults > 0 && results.items.length > 0) {
      const item = results.items[0];

      // Extract unique identifiers
      const identifiers = item.identifiers.flatMap((marketplace) =>
        marketplace.identifiers
          .filter((identifier) =>
            ["GTIN", "EAN", "UPC"].includes(identifier.identifierType)
          )
          .map((identifier) => identifier.identifier)
      );
      const uniqueIdentifiers = [...new Set(identifiers)];

      // Get title
      const title =
        item.attributes?.item_name?.find(
          (name) => name.language_tag === "es_MX"
        )?.value || "Sin título";

      // Get image
      const image = item.images?.[0]?.images?.[0]?.link || null;
      //  console.log(JSON.stringify({ uniqueIdentifiers, title, image }, null, 2));
      return { uniqueIdentifiers, title, image };
    } else {
      console.log("No se encontraron detalles para el ASIN proporcionado.");
      return { uniqueIdentifiers: [], title: "Sin título", image: null };
    }
  } catch (error) {
    console.error("Error al obtener los detalles por ASIN:", error);
    return { uniqueIdentifiers: [], title: "Sin título", image: null };
  }
};






module.exports = {
  getAsinPrice,
  getAsinDetails,
};
// ./services/keepaService.js
const { callKeepaAPI } = require('../config/keepaConfig');



//Busqueda de productos vendidos por amazon en la categoria de belleza
const findProductsFromKeepa = async (category) => {
  const productSearchParams = {
    domain: 11,
    selection: JSON.stringify({
      current_AMAZON_gte: 15000,
      current_AMAZON_lte: 400000,
      rootCategory: category,
     sort: [["current_SALES", "asc"]], // Ordenar por ventas actuales
    // sort: [[ "deltaPercent30_AMAZON", "desc"]], // Ordenar por variación de precio en los últimos 30 días
    // sort: [[ "deltaPercent90_AMAZON", "desc"]], // Ordenar por variación de precio en los últimos 30 días
    //  sort: [[ "current_AMAZON", "asc"]], // Ordenar precio actual de menor a mayor
    //  sort: [[ "current_AMAZON", "desc"]], // Ordenar precio actual de mayor a menor
      productType: [0, 1, 2],
      page: 0,
      perPage: 10000
    }),
  };

  const data = await callKeepaAPI("/query", productSearchParams);
  console.log(JSON.stringify(data.asinList, null, 2));
  return data.asinList;
};


const getTokenLeft = async () => {
  try {
      const endpoint = '/token';
      const response = await callKeepaAPI(endpoint);
      return response.tokensLeft; // Retorna directamente los datos de la respuesta
  } catch (error) {
      console.error('Error al obtener los tokens restantes:', error);
      throw error;
  }
}


  //getSellerId("A2RIC6EIHFYJ8E")
module.exports = {
    findProductsFromKeepa,
    getTokenLeft
}